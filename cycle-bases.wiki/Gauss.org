#+OPTIONS: tex:t

All arithmetics performed in F_{p}, p prime.
!The following is pseudo code! 

*** ordering of vectors
The vectors should be ordered to extend the chevron form properly. For this, a vector of length n is smaller if the first digit differing is smaller in the usual order (in Z). With implementing this order, the list of vectors can (easily) be ordered.
The ordering of vectors is as follows:

u < v :\Leftrightarrow u_{j} = v_{j}, u_{i} < v_{i}, j<i, i = min {k \in [1:n]: v_{k} \neq u_{k} } 


*** extend base
The base constructed by the vectors (in lower chevron form), and thus the test for linear independence, is done by extending the base. If a vector meant to extend the base is linear dependent (i.e. would be eliminated by Gauss), it will not extend the base (or included as the 0 vector).

The base is extended by adding a vector (1st argument) to the list of the current base / list of vectors (2nd argument potentially containing 0-vectors). This assumes an order of the list according to aforementioned order relation.

The base is extended by adding a 'reduced' vector (i.e. one fitting in lower chevron form) to it if it is linear independent wrt the other vectors (i.e. not reduced to the 0-vector); otherwise the vector is discarded.

A vector is reduced relative to a base by recursively subtracting the k-multiple of the first non-zero entry of the remaining (i.e. not yet reduced list) vectors and reducing the 'partially reduced' vector wrt the rest of the set of linearly independent vectors.

extendBase Vector [Vector] \rightarrow [Vector] 

reduceVector u v = u+k*v, k*v_{i}=-u_{i}, i = min {i \in [1:n], v_{i} \neq 0 }

extendBase u (v:vs) = fold reduceVector u (v:vs) 


*** upper chevron
The idea to derive the upper chevron form of the constructed matrix is to first normalize the list (right operator), with a normalization that makes the first non-zero entry of a vector a 1, and then to subtract multiples of the smaller vectors to the larger ones (with the order relation mentioned above), so that the position where the smaller vector has its first non-zero entry will be 0 in the larger vectors.
That is:

upperChevron [l] = constructChevron l . normalize l

normalize [l] = map normalize l

normalize u = u*k, k=u^{-1}_{i}, i =min {j \in [1:n], u_{j} \neq 0}

constructChevron [l:[]] = l

constructChevron (l:ls) = l : (constructChevron ls . normalizePosition l ls)

normalizePosition u v = v+k*u, k*u_{i}=v^{-1}_{i}, i=min{k \in [1:n], u_{k} \neq 0}
(Assumes u < v)

normalizePosition (l:ls) = map (normalizePosition l) ls


*** Vector operations:
For all operations, a custom operation is defined. That is that the vector operations are applied elementwise in F_{p}, that is:

k*u = (k*u_{1},...,k*u_{n})

u+v = (u_{1} \oplus v_{1},...,u_{n} \oplus v_{n}),


Here * is the common multiplication, where \oplus is the modulo addition, i.e.:

a \oplus b = (a+b) mod p